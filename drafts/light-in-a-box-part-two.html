<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"
      xmlns:og="http://ogp.me/ns#"
      xmlns:fb="https://www.facebook.com/2008/fbml">
<head>
    
    <script type= "text/javascript">
        var s = document.createElement('script');
        s.type = 'text/javascript';
        s.src = 'https:' == document.location.protocol ? 'https://c328740.ssl.cf1.rackcdn.com/mathjax/latest/MathJax.js' : 'http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML'; 
        s[(window.opera ? "innerHTML" : "text")] =
            "MathJax.Hub.Config({" + 
            "    config: ['MMLorHTML.js']," + 
            "    jax: ['input/TeX','input/MathML','output/HTML-CSS','output/NativeMML']," +
            "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } }," + 
            "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
            "    tex2jax: { " +
            "        inlineMath: [ ['$','$'] ], " +
            "        displayMath: [ ['$$','$$'] ]," +
            "        processEscapes: true }, " +
            "    'HTML-CSS': { " +
            "        styles: { '.MathJax .mo, .MathJax .mi': {color: 'black ! important'}} " +
            "    } " +
            "}); ";
        (document.body || document.getElementsByTagName('head')[0]).appendChild(s);
    </script>

    <title>Light in a Box (Part&nbsp;Two)</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <!-- Open Graph tags -->

            <meta property="og:type" content="article"/>
            <meta property="og:title" content="Light in a Box (Part&nbsp;Two)"/>
            <meta property="og:url" content="http://markbrown.io/light-in-a-box-part-two.html"/>
            <meta property="og:description" content="In part one we looked at the basics of generating the initial directions of the light in our simulation. In this post we’ll look at how we deal with reflections from the surfaces of the box. For the moment we’ll say the surfaces of the box are completely ..."/>

    <!-- Bootstrap -->
        <link rel="stylesheet" href="http://markbrown.io/theme/css/bootstrap.simplex.min.css" type="text/css"/>
    <link href="http://markbrown.io/theme/css/font-awesome.min.css" rel="stylesheet">
    <link href="http://markbrown.io/theme/css/bootstrap-glyphicons.css" rel="stylesheet">
    <link href="http://markbrown.io/theme/css/pygments.css" rel="stylesheet">
    <link rel="stylesheet" href="http://markbrown.io/theme/css/style.css" type="text/css"/>
    <!-- JavaScript plugins (requires jQuery) -->
    <script src="//code.jquery.com/jquery.min.js"></script>


</head>
<body>
<nav class="navbar navbar-default navbar-fixed-top" role="navigation">
    <div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="http://markbrown.io" class="navbar-brand">markbrown.io</a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                        <li><a href="http://markbrown.io/about/">About</a></li>
                        <li><a href="http://markbrown.io/cv/">Curriculum&nbsp;Vitae</a></li>
                        <li><a href="http://markbrown.io/research/">Research</a></li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
                <li><a href="http://markbrown.io/archives.html"><i class="icon-th-list"></i>Archives</a></li>
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</nav>
<!-- /.navbar -->
<div class="container">
    <div class="row">
        <div class="col-lg-9">
    <section id="content">
        <article>
            <header class="page-header">
                <h1>
                    <a href="http://markbrown.io/light-in-a-box-part-two.html"
                       rel="bookmark"
                       title="Permalink to Light in a Box (Part&nbsp;Two)">
                        Light in a Box (Part&nbsp;Two)
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
                    <div class="panel-body">
<footer class="post-info">
    <span class="label label-default">Date</span>
    <span class="published">
        Sun 24 March 2013
    </span>




	<span class="label label-default">Tags</span>
		<a href="http://markbrown.io/tag/python.html">python</a>
	        /
		<a href="http://markbrown.io/tag/light.html">light</a>
	        /
		<a href="http://markbrown.io/tag/matplotlib.html">matplotlib</a>
</footer><!-- /.post-info -->                    </div>
                </div>
                <p>In <a class="reference external" href="http://markbrown.io/light-in-a-box-part-one.html">part one</a> we looked at the basics of generating the initial directions of the light in our simulation. In this post we&#8217;ll look at how we deal with reflections from the surfaces of the box. For the moment we&#8217;ll say the surfaces of the box are completely reflective. We&#8217;ll deal with the transmission through the surfaces in another&nbsp;post.</p>
<div class="section" id="the-unified-model">
<h2>The <span class="caps">UNIFIED</span>&nbsp;Model</h2>
<p>Specular, to mean mirror-like, reflections are the simplest we can consider. In the cases where we have a highly polished flat surface, this kind of reflection is pretty much correct. However when we start seeing imperfections in the surface, roughness, this description breaks down. One of the models we can consider, <em>the <span class="caps">UNIFIED</span> model</em>, is what we&#8217;ll implement today. As with all models of rough surfaces a great pinch of salt must be taken when using them. In any case, let&#8217;s get to&nbsp;it.</p>
<p>The <span class="caps">UNIFIED</span> model is a popular method uses to describe rough surfaces in some  <a class="reference external" href="http://mathworld.wolfram.com/MonteCarloMethod.html">Monte Carlo</a> ray-tracing programs. One I&#8217;m familiar with is known as <em>Geant4</em>. The model essentially breaks down reflections down into 4 possible components, each with a chance of occuring. These components&nbsp;are</p>
<ol class="arabic simple">
<li>Specular : Mirror-like&nbsp;reflection</li>
<li>Backscatter : Back the way the photon&nbsp;came.</li>
<li>Lobe : Spread the reflected energy out into an outward cone described by a Gaussian&nbsp;profile.</li>
<li>Lambertian : Spread energy equally in every direction, regardless of incoming&nbsp;direction.</li>
</ol>
<p>We&#8217;ll look at how to implement each of these in&nbsp;turn.</p>
</div>
<div class="section" id="specular-reflection">
<h2>1. Specular&nbsp;Reflection</h2>
<img alt="Specular reflection" src="images/specular.png" style="width: 50%;" />
<p>Behold my wonky diagram! I&#8217;ve rotated it purely to make it clear we&#8217;re trying to describe $n_f$ in terms of the initial directin, $n_i$ and the surface normal, $S$. For specular reflection we also can state that the incoming angle is equal to the outgoing angle. Using just this information we draw the above diagram. On this diagram we&#8217;ve also drawn two vectors $a$ and $b$. The first thing to notice though is that we have two closed triangles. Meaning we can&nbsp;write</p>
<p>\begin{equation}
\vec{n_i} = \vec{a} + \vec{b}
\label{nieqn}
\end{equation}
and
\begin{equation}
\vec{n_f} = \vec{a} - \vec{b}
\end{equation}
Which is nice. Let&#8217;s say we want to find $n_f$ from $n_i$ - i.e. the direction of reflection. Well from the figure we can see that
\begin{equation}
\vec{n_f} = 2\vec{a}-\vec{n_i}
\label{nfeqn}
\end{equation}
Which again is nice, but not quite there yet. We don&#8217;t know what $a$ or $b$ even is yet. Well we can see that $b$ and $S$ are the in same direction. We also remember that the magnitude of direction vectors is 1. Just by looking (it is a right angled triangle after all), we can see that the magnitude of $b$ must be less than this. So the question is, how much of $n_i$ is in the direction of $b$? Luckily for us the answer is&nbsp;simply</p>
<p>\begin{equation}
\vec{b} = (\vec{n_i}\cdot \vec{S})\vec{S}
\end{equation}
The bracketed part gives us the magnitude and $S$ gives us the direction of $b$. Now we&#8217;re making progress! We can relate $a$ to $b$ by equation $\ref{nieqn}$ such&nbsp;that</p>
<p>\begin{equation}
\vec{a} = \vec{n_i} - (\vec{n_i}\cdot \vec{S})\vec{S}
\end{equation}
Combined with equation $\ref{nfeqn}$ we reach our final answer
\begin{equation}
\boxed{\vec{n_f} = \vec{n_i} - 2(\vec{n_i}\cdot \vec{S})\vec{S}}&nbsp;\end{equation}</p>
<p>So as long we know the surface vector and initial direction, we can calculate the reflection direction easily&nbsp;enough.</p>
</div>
<div class="section" id="backscattering-reflection">
<h2>2. Backscattering&nbsp;Reflection</h2>
<p>Backscattering is probably the easiest to program in, as we&#8217;re simply going back the way we came. Such that
\begin{equation}
\vec{n_f} = -\vec{n_i}&nbsp;\end{equation}</p>
</div>
<div class="section" id="lobe-reflection">
<h2>3. Lobe&nbsp;Reflection</h2>
<img alt="lobe reflection" class="align-center" src="images/lobe-gaussian.png" style="width: 60%;" />
<p>This is where things start getting much more amusing. In the previous cases we&#8217;ve had one photon coming in and one coming out. In this case the energy of the incoming photon will spread out in a cone about the $n_f$ direction we derived earlier. As we&#8217;re dealing with particles coming in, we&#8217;ll stick to describing particles coming out. Namely that we&#8217;ll spread the incoming energy amongst $M$ new photons, each with an energy and direction related to the kind of light spread we would like. So the question becomes what is the energy $E_i$ and direction $n_{i}$ of each new&nbsp;photon?</p>
<p>There are two parts to this. Firstly we need to generate the directions. The amount of energy each new photon will have will be related to this also. Secondly each direction vector needs to be rotated such that it points in the &#8216;correct&#8217; manner relative to the surface normal and the original specular outgoing vector, $n_f$, we&#8217;ve derived earlier. We&#8217;ll start with this second&nbsp;part.</p>
<p><strong>Rotation of a&nbsp;Vector</strong></p>
<p>There are a few ways to rotate an arbitrary vector (<a class="reference external" href="http://en.wikipedia.org/wiki/Rotation_matrix">obligatory wikipedia link</a>), we will however save our sanity (and hopefully some time) by using Euler Angles. In this we apply a rotation about the cartesian $x,y,z$ axes in turn. This gives us a rotation matrix of the form
\begin{equation}
R = R_z(\psi) , R_y(\theta) , R_x(\phi)\,=&#92;&#92;
\begin{bmatrix}\cos\theta \cos\psi&amp;-\cos\phi\sin\psi + \sin\phi \sin\theta \cos\psi&amp;\sin\phi \sin\psi + \cos\phi \sin\theta \cos\psi &#92;&#92;
\cos\theta \sin\psi&amp; \cos\phi \cos\psi + \sin\phi \sin\theta \sin\psi&amp;-\sin\phi \cos\psi + \cos\phi \sin\theta \sin\psi &#92;&#92;
-\sin\theta&amp;\sin\phi \cos\theta&amp;\cos\phi \cos\theta \end{bmatrix}&nbsp;\end{equation}</p>
<p>Combined with
\begin{equation}
\vec{v}^\prime = R\cdot \vec{v}&nbsp;\end{equation}</p>
<p>We now have everything we need to rotate any 3D cartesian vector by angles $\phi,\theta,\psi$. Implemented in Python this&nbsp;becomes</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">dot</span><span class="p">,</span><span class="n">sin</span><span class="p">,</span><span class="n">cos</span><span class="p">,</span><span class="n">pi</span>
<span class="k">def</span> <span class="nf">RotateVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">phi</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">theta</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">psi</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    rotate vector &#39;v&#39; using Euler Angles</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">R</span> <span class="o">=</span> <span class="p">((</span>
    <span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">psi</span><span class="p">)),</span>
    <span class="p">(</span><span class="o">-</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span><span class="o">+</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">psi</span><span class="p">)),</span>
    <span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span><span class="o">+</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">psi</span><span class="p">)),</span>
    <span class="p">),(</span>
    <span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">psi</span><span class="p">)),</span>
    <span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span><span class="o">+</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">psi</span><span class="p">)),</span>
    <span class="p">(</span><span class="o">-</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">psi</span><span class="p">)</span><span class="o">+</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">psi</span><span class="p">)),</span>
    <span class="p">),(</span>
    <span class="p">(</span><span class="o">-</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)),</span>
    <span class="p">(</span><span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)),</span>
    <span class="p">(</span><span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)),</span>
    <span class="p">))</span>
    <span class="k">return</span> <span class="n">dot</span><span class="p">(</span><span class="n">R</span><span class="p">,</span><span class="n">v</span><span class="p">)</span>
</pre></div>
<p>To which a quick test will&nbsp;give</p>
<div class="highlight"><pre><span class="n">v</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">&quot;No Rotation&quot;</span><span class="p">,</span><span class="n">RotateVector</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">&quot;90 degrees in Theta&quot;</span><span class="p">,</span><span class="n">RotateVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">theta</span><span class="o">=</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">&quot;90 degrees in Phi&quot;</span><span class="p">,</span><span class="n">RotateVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">phi</span><span class="o">=</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">&quot;90 degrees in Psi&quot;</span><span class="p">,</span><span class="n">RotateVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">psi</span><span class="o">=</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>

<span class="c">##Output</span>
<span class="o">&gt;&gt;</span><span class="n">No</span> <span class="n">Rotation</span> <span class="p">[</span> <span class="mf">1.</span>  <span class="mf">0.</span>  <span class="mf">0.</span><span class="p">]</span>
<span class="o">&gt;&gt;</span><span class="mi">90</span> <span class="n">degrees</span> <span class="ow">in</span> <span class="n">Theta</span> <span class="p">[</span>  <span class="mf">6.12303177e-17</span>   <span class="mf">0.00000000e+00</span>  <span class="o">-</span><span class="mf">1.00000000e+00</span><span class="p">]</span>
<span class="o">&gt;&gt;</span><span class="mi">90</span> <span class="n">degrees</span> <span class="ow">in</span> <span class="n">Phi</span> <span class="p">[</span> <span class="mf">1.</span>  <span class="mf">0.</span>  <span class="mf">0.</span><span class="p">]</span>
<span class="o">&gt;&gt;</span><span class="mi">90</span> <span class="n">degrees</span> <span class="ow">in</span> <span class="n">Psi</span> <span class="p">[</span>  <span class="mf">6.12303177e-17</span>   <span class="mf">1.00000000e+00</span>   <span class="mf">0.00000000e+00</span><span class="p">]</span>
</pre></div>
<p>Which is err&#8230;what! This would be a floating-point rounding error. In this case the error is stupendously tiny and can (hopefully) be ignored. But consider a case where we wish to compare two directions. Such&nbsp;as</p>
<div class="highlight"><pre><span class="p">[</span>  <span class="mf">6.12303177e-17</span> <span class="p">,</span>  <span class="mf">0.00000000e+00</span> <span class="p">,</span> <span class="o">-</span><span class="mf">1.00000000e+00</span><span class="p">]</span> <span class="o">==</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="o">&gt;&gt;</span><span class="bp">False</span>
</pre></div>
<p>Not quite ideal really. It is exactly these sorts of mistakes we should always be wary of introducing into our code. We could write a new vector class to override this behaviour or start doing some fancy thresholding. Alternatively we can check to see if numpy (or scipy) has the functionality completed for us! In this&nbsp;case</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">allclose</span>

<span class="n">allclose</span><span class="p">([</span>  <span class="mf">6.12303177e-17</span> <span class="p">,</span>  <span class="mf">0.00000000e+00</span> <span class="p">,</span> <span class="o">-</span><span class="mf">1.00000000e+00</span><span class="p">],[</span><span class="mi">0</span> <span class="p">,</span> <span class="mi">0</span> <span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="o">&gt;&gt;</span><span class="bp">True</span>
</pre></div>
<p>does the job nicely. Remember try not to reinvent the wheel. Especially when wheels made by scientists tend to be knocked up quickly and approximately&nbsp;square.</p>
<p><strong>Directions for Lobe&nbsp;Reflection</strong></p>
<p>So Lobe reflections. Specifically we&#8217;re looking to generate a Gaussian profile and spin that around the centre axis to produce a cone. Why a Gaussian I hear you ask? Not a clue, probably something to do with the central limit theorem. In all seriousness any distribution we chose should naturally be symmetrical about no deviation at all, and should probably drop to zero fairly&nbsp;sharpish.</p>
<p>So Gaussian profile you say. What on earth do you mean? Well we&#8217;re going to consider each photon to be &#8216;kicked&#8217; from the $n_f$ direction we&#8217;ve predicted earlier by a small vector. The size of this vector will be related to this Gaussian distribution. Specifically to the standard deviation of it. This parameter which we&#8217;ll call $\sigma_{\alpha}$. The bigger this number, the bigger the&nbsp;kick.</p>
<p>We&#8217;ll define $N$ such vectors about the $z$&nbsp;axis</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">norm</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">linspace</span>
<span class="kn">from</span> <span class="nn">random</span> <span class="kn">import</span> <span class="n">uniform</span>

<span class="k">def</span> <span class="nf">LobeReflection</span><span class="p">(</span><span class="n">N</span><span class="p">,</span><span class="n">stddev</span> <span class="o">=</span> <span class="mf">1.3</span><span class="p">,</span><span class="n">dist</span><span class="o">=</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Generate N beams with profile given by the distribution with standard deviation of</span>
<span class="sd">    angular spread given by stddev (in degrees).</span>

<span class="sd">    Default gives normal distribution with a standard deviation of 1.3 degrees</span>
<span class="sd">    (corresponding to a polished surface - Moses2010)</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">Vectors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">Weights</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">Vectors</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">:</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">pi</span> <span class="c">#random phi (in radians)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">dist</span><span class="p">(</span><span class="n">scale</span><span class="o">=</span><span class="n">stddev</span><span class="o">*</span><span class="n">pi</span><span class="o">/</span><span class="mi">180</span><span class="p">)</span><span class="o">.</span><span class="n">rvs</span><span class="p">()</span> <span class="c">#random theta (in radians)</span>

        <span class="n">w</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">pdf</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>

        <span class="n">Weights</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w</span><span class="p">)</span>
        <span class="n">Vectors</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">))</span>

    <span class="n">Weights</span> <span class="o">/=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">Weights</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Weights</span><span class="p">,</span><span class="n">Vectors</span>
</pre></div>
<p>The default value is $1.3^\circ$ which is a value I&#8217;ve handily pulled from a <a class="reference external" href="http://ieeexplore.ieee.org/xpl/login.jsp?tp=&amp;arnumber=5485130&amp;url=http%3A%2F%2Fieeexplore.ieee.org%2Fxpls%2Fabs_all.jsp%3Farnumber%3D5485130">research paper</a> (subscription required). The above uses the <em>rvs()</em> function call to to a scipy.stats distribution. This will generate a random number based on the distribution it&#8217;s called from. Particularly handy! As we expect all directions about the axis to be equally likely, the second number is uniform random number. Using those two we can find everything we&nbsp;need.</p>
<p>Below we use the function we&#8217;ve just written along with the rotation code to&nbsp;produce</p>
<div class="highlight"><pre><span class="kn">from</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">import</span> <span class="n">figure</span><span class="p">,</span><span class="n">plot</span><span class="p">,</span><span class="n">show</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="kn">import</span> <span class="n">Axes3D</span>

<span class="n">Weights</span><span class="p">,</span><span class="n">Directions</span> <span class="o">=</span> <span class="n">LobeReflection</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span><span class="n">stddev</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span><span class="n">dist</span><span class="o">=</span><span class="n">stats</span><span class="o">.</span><span class="n">norm</span><span class="p">)</span>

<span class="c">#rotates each vector in turn</span>
<span class="n">Directions</span>  <span class="o">=</span> <span class="p">[</span><span class="n">RotateVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">theta</span><span class="o">=</span><span class="n">pi</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Directions</span><span class="p">]</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span><span class="n">projection</span><span class="o">=</span><span class="s">&#39;3d&#39;</span><span class="p">)</span>

<span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">),</span><span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">Directions</span><span class="p">,</span><span class="n">Weights</span><span class="p">):</span>
    <span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">,</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">y</span><span class="p">,</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">z</span>
    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="s">&#39;k-&#39;</span><span class="p">)</span>

<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>

<span class="n">show</span><span class="p">()</span>
</pre></div>
<p>Will produce the following image. In this case we scale the length of each vector to indicate the relative amount of energy in each&nbsp;photon.</p>
<img alt="lobe reflection direction vectors" src="images/lobevectors.png" style="width: 50%;" />
</div>
<div class="section" id="lambertian-reflection">
<h2>4. Lambertian&nbsp;Reflection</h2>
<img alt="lambertian reflection" class="align-center" src="images/lambertian.png" style="width: 60%;" />
<p>Lambertian, equal energy in every direction, is something we&#8217;ve in fact written earlier! Looking again at <a class="reference external" href="http://markbrown.io/light-in-a-box-part-one.html">part one</a>, we just need to modify the code used to generate our initial isotropic source to produce a hemisphere. The code therefore&nbsp;becomes</p>
<div class="highlight"><pre><span class="k">def</span> <span class="nf">LambertianReflection</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
    <span class="sd">&#39;&#39;&#39;</span>
<span class="sd">    Directions with equal likelihood into a hemisphere</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="n">Vectors</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">Vectors</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">N</span><span class="p">:</span>
        <span class="n">x1</span> <span class="o">=</span> <span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">x2</span> <span class="o">=</span> <span class="n">uniform</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">x1</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">x2</span><span class="o">**</span><span class="mi">2</span> <span class="o">&lt;</span><span class="mi">1</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x1</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">x2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">x2</span><span class="o">*</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">x1</span><span class="o">**</span><span class="mi">2</span><span class="o">-</span><span class="n">x2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="n">z</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="p">(</span><span class="n">x1</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="n">x2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">z</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="n">Vectors</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">))</span>

    <span class="n">Weights</span> <span class="o">=</span> <span class="n">ones</span><span class="p">(</span><span class="n">N</span><span class="p">)</span><span class="o">/</span><span class="n">N</span>
    <span class="k">return</span> <span class="n">Weights</span><span class="p">,</span><span class="n">Vectors</span>
</pre></div>
<p>In the above we distribute the energy of the incoming particle equally between all exiting photons. Again we can plot this as we did previously with the&nbsp;code</p>
<div class="highlight"><pre><span class="n">Weights</span><span class="p">,</span><span class="n">Directions</span> <span class="o">=</span> <span class="n">LambertianReflection</span><span class="p">(</span><span class="mi">1000</span><span class="p">)</span>

<span class="c">#rotates each vector in turn</span>
<span class="n">Directions</span>  <span class="o">=</span> <span class="p">[</span><span class="n">RotateVector</span><span class="p">(</span><span class="n">v</span><span class="p">,</span><span class="n">theta</span><span class="o">=</span><span class="n">pi</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">Directions</span><span class="p">]</span>

<span class="n">fig</span> <span class="o">=</span> <span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span><span class="n">projection</span><span class="o">=</span><span class="s">&#39;3d&#39;</span><span class="p">)</span>

<span class="k">for</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span><span class="n">z</span><span class="p">),</span><span class="n">w</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">Directions</span><span class="p">,</span><span class="n">Weights</span><span class="p">):</span>
    <span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span> <span class="o">=</span> <span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">x</span><span class="p">,</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">y</span><span class="p">,</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">w</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">z</span>
    <span class="n">plot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span><span class="n">Y</span><span class="p">,</span><span class="n">Z</span><span class="p">,</span><span class="s">&#39;k-&#39;</span><span class="p">)</span>


<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_zlim</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

<span class="n">ax</span><span class="o">.</span><span class="n">view_init</span><span class="p">(</span><span class="n">elev</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span><span class="n">azim</span><span class="o">=</span><span class="mi">45</span><span class="p">)</span>

<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
<span class="n">show</span><span class="p">()</span>
</pre></div>
<p>to give the following&nbsp;image.</p>
<img alt="Lambertian reflection direction vectors" src="images/lambertianvectors.png" style="width: 50%;" />
</div>
<div class="section" id="summary">
<h2>Summary</h2>
<p>We&#8217;ve now got our box, our light source and four different ways we can consider reflections. Next time we&#8217;ll look at how we&#8217;ll consider photons moving in the box. We&#8217;ll also look at conditions for detection or destruction of a&nbsp;photon.</p>
</div>

            </div>
<!--            <!-- /.entry-content -->
<!--            -->
<!--                <hr />
    <section class="comments" id="comments">
        <h2>Comments</h2>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'markbrownio'; // required: replace example with your forum shortname
            var disqus_identifier = 'light-in-a-box-part-two';
            var disqus_url = 'http://markbrown.io/light-in-a-box-part-two.html';

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function () {
                var dsq = document.createElement('script');
                dsq.type = 'text/javascript';
                dsq.async = true;
                dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by
            Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

    </section>
-->
        </article>
    </section>

        </div>
        <div class="col-lg-3 well well-sm" id="sidebar">
<aside>
    <section>

            <li class="list-group-item"><h4><i class="icon-home icon-large"></i>Contact Me</h4></li>
            <center>
            <a href="http://www.linkedin.com/pub/mark-s-brown/48/95a/70"><i class="icon-linkedin-sign icon-large" ></i></a>

            <script language="JavaScript">
              u = 'sandcalc';
              document.write('<a href=\"skype:' + u + '?call' + '\" target=\"_blank\">');
            </script>
            <i class="icon-skype icon-large"></i>

            <script language="JavaScript">
              u = 'zcicg94';
              s = 'ucl.ac.uk';
              document.write('<a href=\"mailto:' + u + '@' + s + '\" target=\"_blank\">');
            </script>
            <i class="icon-envelope icon-large"></i>
<!--            <a href="http://markbrown.io/feeds/all.rss.xml" rel="alternate" title="Recent Blog Posts"><i class="icon-rss icon-large"></i></a>-->
            </center>
            </li>

<!--            <li class="list-group-item"><a href="http://markbrown.io/tags.html"><h4><i class="icon-tags icon-large"></i>Tags</h4></a></li>-->
<!--            -->
<!--                <li class="list-group-item tag-4">-->
<!--                    <a href="http://markbrown.io/tag/ccc.html">-->
<!--                        ccc-->
<!--                    </a>-->
<!--                </li>-->
<!--            -->
<!--                <li class="list-group-item tag-4">-->
<!--                    <a href="http://markbrown.io/tag/crlb.html">-->
<!--                        crlb-->
<!--                    </a>-->
<!--                </li>-->
<!--            -->
<!--                <li class="list-group-item tag-4">-->
<!--                    <a href="http://markbrown.io/tag/scintillator.html">-->
<!--                        scintillator-->
<!--                    </a>-->
<!--                </li>-->
<!--            -->
<!--                <li class="list-group-item tag-4">-->
<!--                    <a href="http://markbrown.io/tag/specular.html">-->
<!--                        specular-->
<!--                    </a>-->
<!--                </li>-->
<!--            -->
<!--                <li class="list-group-item tag-4">-->
<!--                    <a href="http://markbrown.io/tag/light.html">-->
<!--                        light-->
<!--                    </a>-->
<!--                </li>-->
<!--            -->
        </ul>
    </section>


    <section>
    <ul class="list-group list-group-flush">
    <li class="list-group-item"><h4><i class="icon-github icon-large"></i>GitHub Repos</h4></li>
        <div id="gh_repos">
            <p class="list-group-item">Status updating...</p>
        </div>
    </ul>
        <script type="text/javascript">
            $(document).ready(function () {
                if (!window.jXHR) {
                    var jxhr = document.createElement('script');
                    jxhr.type = 'text/javascript';
                    jxhr.src = 'http://markbrown.io/theme/js/jXHR.js';
                    var s = document.getElementsByTagName('script')[0];
                    s.parentNode.insertBefore(jxhr, s);
                }

                github.showRepos({
                    user: 'marksbrown',
                    count: 5,
                    skip_forks: false,
                    target: '#gh_repos',
                    sort_attribute: 'pushed_at',
                    sort_descending: true
                });
            });
        </script>
        <script src="http://markbrown.io/theme/js/github.js" type="text/javascript"></script>
    </section>
</aside>        </div>
    </div>
</div>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="http://markbrown.io/theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="http://markbrown.io/theme/js/respond.min.js"></script>
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'markbrownio'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function () {
            var s = document.createElement('script');
            s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
    </script>
</body>
</html>